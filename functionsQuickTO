using Ferrite, Parameters

function quad(x,y,vec; pa = 1)
  quad=zeros(y,x)
  for iel in 1:length(vec)
    # Line of current element
    i=floor(Int32,(iel-1)/x)+1
    # Column of current element
    j=iel-floor(Int32,(iel-1)/x)*x
    pa == 2 ? quad[y-i+1,j]=vec[iel] : quad[i,j]=vec[iel]
  end
  return quad'
end

function mshData(meshSize)
  
  # Create vector of (float, float) tuples with node coordinates for "node_coords"
  # Supposes rectangular elements with unit sides staring at postition (0.0, 0.0)
  # size = (x, y) = quantity of elements in each direction
  
  coordinates = Array{Tuple{Float64, Float64}}(undef, (meshSize[1] + 1)*(meshSize[2] + 1))
  for line in 1:(meshSize[2] + 1)
    coordinates[(line + (line - 1)*meshSize[1]):(line*(1 + meshSize[1]))] .= [((col - 1)/1, (line - 1)/1) for col in 1:(meshSize[1] + 1)]
  end
  
  # Create vector of tuples of integers for "cells"
  # Each line refers to a cell/element and lists its nodes in counter-clockwise order
  
  g_num = Array{Tuple{Vararg{Int, 4}}, 1}(undef, prod(meshSize))
  for elem in 1:prod(meshSize)
    dd = floor(Int32, (elem - 1)/meshSize[1]) + elem
    g_num[elem] = (dd, dd + 1, dd + meshSize[1] + 2, dd + meshSize[1] + 1)
  end
  
  return coordinates, g_num
  
end


# Reshape densities vector to mirror mesh layout (quad()), then plot using Makie.heatmap()
dispDens(FEAparams, problem) = display(
  Makie.heatmap(quad(FEAparams.meshSize[1],
  FEAparams.meshSize[2],
  FEAparams.simps[problem].result.topology))
)

# Same as dispDens, but acessing NLopt's solution format, instead of NonconvexMMA's
dispNLopt(FEAparams, problem) = display(
  Makie.heatmap(quad(FEAparams.meshSize[1],
  FEAparams.meshSize[2],
  FEAparams.simps[problem].minimizer))
)

# write volume fractions to txt file
writeVolFrac(FEAparameters, i) = @printf FEAparameters.fileIDs["volFracID"] "%0.5f\n" FEAparameters.V[i]

# write displacements to txt file
function writeDisp(FEAparameters, i, disp)
  write(FEAparameters.fileIDs["dispID"], "########_displacements_of_problem_$i\n")
  [@printf FEAparameters.fileIDs["dispID"] "%0.5f " disp[dof] for dof in 1:length(disp)]
  write(FEAparameters.fileIDs["dispID"], "\n\n")
end

# write topology, von Mises stresses or strain energy to txt file
function writeField(FEAparameters, i, file, field)
  if file == "topoID"
    write(FEAparameters.fileIDs[file], "########_topology_of_problem_$i\n")
  elseif file == "vonMisesID"
    write(FEAparameters.fileIDs[file], "########_vonMises_field_of_problem_$i\n")
  elseif file == "energyID"
    write(FEAparameters.fileIDs[file], "########_strain_energy_field_of_problem_$i\n")
  end
  quadField = quad(FEAparameters.meshSize[1], FEAparameters.meshSize[2], field)
  for lin in 1:FEAparameters.meshSize[2]
      lin == 1 && (col = 1)
      # println("lin $lin col $col")
      ######## julia is inverting the indices I use to acces quadField
      ######## the order of the indices in the next line is actually wrong, but now it works ¯\_(ツ)_/¯
      [@printf FEAparameters.fileIDs[file] "%0.5f " quadField[col, lin] for col in 1:FEAparameters.meshSize[1]]
      @printf FEAparameters.fileIDs[file] "\n"
  end
  write(FEAparameters.fileIDs[file], "\n")
end